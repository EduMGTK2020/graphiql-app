var b=Object.defineProperty;var y=(r,t,e)=>t in r?b(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var f=(r,t,e)=>(y(r,typeof t!="symbol"?t+"":t,e),e);import{r as s}from"./react-d84e5e68.js";function l(r,t,e,o){Object.defineProperty(r,t,{get:e,set:o,enumerable:!0,configurable:!0})}var E={};l(E,"ErrorBoundary",()=>$);var m={};l(m,"ErrorBoundaryContext",()=>p);const p=s.createContext(null),u={didCatch:!1,error:null};class $ extends s.Component{constructor(){super(...arguments);f(this,"state",u);f(this,"resetErrorBoundary",(...e)=>{var a,n;const{error:o}=this.state;o!==null&&((n=(a=this.props).onReset)==null||n.call(a,{args:e,reason:"imperative-api"}),this.setState(u))})}static getDerivedStateFromError(e){return{didCatch:!0,error:e}}componentDidCatch(e,o){var a,n;(n=(a=this.props).onError)==null||n.call(a,e,o)}componentDidUpdate(e,o){var d,c;const{didCatch:a}=this.state,{resetKeys:n}=this.props;a&&o.error!==null&&C(e.resetKeys,n)&&((c=(d=this.props).onReset)==null||c.call(d,{next:n,prev:e.resetKeys,reason:"keys"}),this.setState(u))}render(){const{children:e,fallbackRender:o,FallbackComponent:a,fallback:n}=this.props,{didCatch:d,error:c}=this.state;let i=e;if(d){const h={error:c,resetErrorBoundary:this.resetErrorBoundary};if(s.isValidElement(n))i=n;else if(typeof o=="function")i=o(h);else if(a)i=s.createElement(a,h);else throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop")}return s.createElement(p.Provider,{value:{didCatch:d,error:c,resetErrorBoundary:this.resetErrorBoundary}},i)}}function C(r=[],t=[]){return r.length!==t.length||r.some((e,o)=>!Object.is(e,t[o]))}var B={};l(B,"useErrorBoundary",()=>k);function x(r){if(r==null||typeof r.didCatch!="boolean"||typeof r.resetErrorBoundary!="function")throw new Error("ErrorBoundaryContext not found");return!0}function k(){const r=s.useContext(p);x(r);const[t,e]=s.useState({error:null,hasError:!1}),o=s.useMemo(()=>({resetBoundary:()=>{r==null||r.resetErrorBoundary(),e({error:null,hasError:!1})},showBoundary:a=>e({error:a,hasError:!0})}),[r==null?void 0:r.resetErrorBoundary]);if(t.hasError)throw t.error;return o}var w={};l(w,"withErrorBoundary",()=>v);function v(r,t){const e=s.forwardRef((a,n)=>s.createElement($,t,s.createElement(r,{...a,ref:n}))),o=r.displayName||r.name||"Unknown";return e.displayName=`withErrorBoundary(${o})`,e}export{$};
